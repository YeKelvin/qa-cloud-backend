[uwsgi]
; uid=www-data # Ubuntu系统下默认用户名
; gid=www-data # Ubuntu系统下默认用户组
# 由于外部还要嵌套Nginx，这里可以使用socket进行通信，如果Nginx和uwsgi部署在同一台机器上，直接使用127.0.0.1
# 如果外部直接通过uwsgi访问服务，需将socket改为http-socket或者http，将127.0.0.1改为0.0.0.0
# 使用nginx连接时使用
socket = 0.0.0.0:5000
# uwsgi不建议使用root权限去启动uwsgi实例
# 可以通过root用户去运行uwsgi文件，当通过uid和gid去修改用户（移除root权限）
# 并且，如果你使用的是socket的通信方式，最好加上chmod-socket字段
; chown-socket=%(uid):www-data
chmod-socket = 664
# 直接做web服务器时使用
;http = 0.0.0.0:5000
# 工作路径
chdir = /app
# flask 对象
module = main:app
# flask应用实例的名称，是flask独有的配置项
# 由于flask存在特殊的机制，可以实例化多个application，需要明确指出，收到请求时，uwsgi应该调用哪个应用实例
callable = app
# master 进程
master = true
# 进程数，可设为机器核数+1
processes = 1
# 每个进程的线程数
threads = 20
# 允许用内嵌的语言启动线程。这将允许你在app程序中产生一个子线程
enable-threads = true
# 开启 websocket
http-websockets = true
gevent = 1000
async = 100
# socket 监听队列大小（default: 100）
listen = 1024
# 为每个工作进程设置请求数的上限。当处理的请求总数超过这个量，进程回收重启。
max-requests = 5000
# uWsgi默认的buffersize为4096，如果请求数据超过这个量会报错。这里设置为64k
buffer-size=65536
# 如果http请求体的大小超过指定的限制，打开http body缓冲，这里为64k
post-buffering=65536
# 在每个worker而不是master中加载应用
lazy-apps = true
# 当服务器退出的时候自动删除 unix socket 文件和 pid 文件
vacuum = true
die-on-term = true
# 启用监控，使用nc 127.0.0.1 9191 查看 (nc 安装:yum -y install nmap-ncat)
; stats = 0.0.0.0:9191
# 避免惊群效应
thunder-lock = true
# 请求超时时间（秒）, 当一个请求花费的时间超过这个时间，那么这个请求都会被丢弃
harakiri = 60
# 当一个请求被harakiri杀掉会输出一条日志
harakiri-verbose=true
# 使进程在后台运行，并将日志输出到指定的日志文件
; daemonize = /var/log/uwsgi/uwsgi.log
# 进程文件
pidfile = /run/uwsgi.pid
# 开启内存使用情况报告
memory-report=true
#设置平滑的重启（直到处理完接收到的请求）的长等待时间(秒)
reload-mercy=10
